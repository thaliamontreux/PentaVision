{% extends 'base.html' %}

{% block title %}Sign in Â· PentaVision{% endblock %}

{% block splash_extra %}
  <div
    id="pv-login-box"
    class="pv-login-box pv-login-box-hidden"
    data-stage="{{ 'totp' if totp_pending else 'primary' }}"
  >
    {% if errors %}
      <div class="pv-alert pv-alert-error pv-mb-3" role="alert">
        <ul>
          {% for error in errors %}
            <li>{{ error }}</li>
          {% endfor %}
        </ul>
      </div>
    {% endif %}

    {% if totp_error %}
      <div class="pv-alert pv-alert-error pv-mb-2" role="alert">
        {{ totp_error }}
      </div>
    {% endif %}

    {% if not totp_pending %}
      <h2 class="pv-login-title">Sign in</h2>

      <form id="pv-login-form-primary" method="post" class="pv-login-form">
        <input type="hidden" name="csrf_token" value="{{ global_csrf_token }}" />
        <input type="hidden" name="next" value="{{ next }}" />

        <div class="pv-field-group">
          <label for="email">Email / Username</label>
          <input
            id="email"
            name="email"
            type="text"
            required
            autocomplete="username"
            value="{{ email }}"
          />
        </div>

        <div class="pv-field-group">
          <label for="password">Password</label>
          <input
            id="password"
            name="password"
            type="password"
            required
            autocomplete="current-password"
          />
        </div>

        <div class="pv-field-group pv-mt-1">
          <div class="pv-login-actions">
            <button
              type="button"
              class="pv-login-button pv-login-button-secondary"
              id="pv-login-passkey-btn"
            >
              Passkey
            </button>
            <button type="submit" class="pv-login-button">
              Sign in
            </button>
          </div>
        </div>
      </form>
    {% else %}
      <h2 class="pv-login-title">Two-factor authentication</h2>
      <p class="pv-text-sm pv-text-light pv-mt-0 pv-mb-3">
        Enter the 6-digit code from your authenticator app to complete sign-in.
      </p>

      <form
        id="pv-login-form-totp"
        method="post"
        action="{{ url_for('main.login_totp') }}"
        class="pv-login-form"
      >
        <input type="hidden" name="csrf_token" value="{{ global_csrf_token }}" />

        <div class="pv-field-group">
          <label for="totp_code">Authentication code</label>
          <input
            id="totp_code"
            name="totp_code"
            type="text"
            autocomplete="one-time-code"
            inputmode="numeric"
            required
          />
        </div>

        <div class="pv-field-group pv-mt-1">
          <div class="pv-login-actions">
            <button type="submit" class="pv-login-button">
              Verify
            </button>
          </div>
        </div>
      </form>
    {% endif %}
  </div>
{% endblock %}

{% block content %}
  {# Main content is intentionally minimal on the login page because the
     primary interaction happens in the splash overlay login / TOTP box. #}
  <script>
    (function () {
      var btn = document.getElementById('pv-login-passkey-btn');
      if (!btn) return;

      function apiPostJson(url, body) {
        return fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify(body || {})
        }).then(function (resp) {
          return resp.json().catch(function () {
            return { error: 'invalid JSON response', status: resp.status };
          });
        });
      }

      function bufferFromBase64Url(b64url) {
        var s = String(b64url || '');
        s = s.replace(/-/g, '+').replace(/_/g, '/');
        var pad = s.length % 4;
        if (pad) {
          s += '='.repeat(4 - pad);
        }
        var binary = atob(s);
        var bytes = new Uint8Array(binary.length);
        for (var i = 0; i < bytes.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function base64UrlFromBuffer(buf) {
        var bytes = new Uint8Array(buf || []);
        var binary = '';
        for (var i = 0; i < bytes.length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      }

      function decodeAssertionOptions(opts) {
        if (!opts) return opts;

        // Some servers return the PublicKeyCredentialRequestOptions object
        // directly instead of wrapping it in { publicKey: ... }. Normalize
        // that here so navigator.credentials.get always sees a publicKey
        // property.
        if (!opts.publicKey) {
          if (opts.public_key) {
            opts = { publicKey: opts.public_key };
          } else if (opts.challenge || opts.allowCredentials) {
            opts = { publicKey: opts };
          }
        }
        if (!opts.publicKey) return opts;

        var pk = opts.publicKey;
        if (pk.challenge) {
          pk.challenge = bufferFromBase64Url(pk.challenge);
        }
        // Edge is strict about the optional "hints" field. We don't rely on
        // it for authentication, so remove it entirely to avoid type errors.
        if (Object.prototype.hasOwnProperty.call(pk, 'hints')) {
          delete pk.hints;
        }
        if (Array.isArray(pk.allowCredentials)) {
          pk.allowCredentials = pk.allowCredentials.map(function (cred) {
            if (cred && cred.id) {
              cred.id = bufferFromBase64Url(cred.id);
            }
            return cred;
          });
        }
        return opts;
      }

      btn.addEventListener('click', function () {
        if (!window.PublicKeyCredential) {
          if (!window.isSecureContext) {
            alert('Passkeys require a secure context (HTTPS or localhost).');
          } else {
            alert('Passkeys/WebAuthn are not available in this browser.');
          }
          return;
        }

        var emailInput = document.getElementById('email');
        var email = emailInput ? String(emailInput.value || '').trim() : '';
        if (!email) {
          alert('Enter your email before using a passkey.');
          return;
        }

        var nextInput = document.querySelector('#pv-login-form-primary input[name="next"]');
        var nextUrl = nextInput ? nextInput.value || '/' : '/';

        apiPostJson('{{ url_for("auth.passkey_login_begin") }}', { email: email })
          .then(function (options) {
            if (options.error) {
              alert('Error: ' + options.error);
              return;
            }
            options = decodeAssertionOptions(options);
            if (!options || !options.publicKey) {
              alert('Error: invalid passkey assertion options.');
              return;
            }
            return navigator.credentials.get(options).then(function (assertion) {
              if (!assertion) {
                throw new Error('No passkey was returned. The request may have been cancelled.');
              }
              var rawIdB64 = base64UrlFromBuffer(assertion.rawId);
              var res = {
                // Ensure id and rawId are identical base64url strings so the
                // backend/python-fido2 sees them as consistent.
                id: rawIdB64,
                rawId: rawIdB64,
                type: assertion.type,
                response: {
                  clientDataJSON: base64UrlFromBuffer(assertion.response.clientDataJSON),
                  authenticatorData: base64UrlFromBuffer(assertion.response.authenticatorData),
                  signature: base64UrlFromBuffer(assertion.response.signature)
                },
                next: nextUrl
              };
              return apiPostJson('{{ url_for("auth.passkey_login_complete") }}', res);
            });
          })
          .then(function (data) {
            if (!data) return;
            if (data.error) {
              alert('Error: ' + data.error);
              return;
            }
            if (data.totp_required) {
              // Backend has stored pending_totp_user_id/pending_totp_next; send
              // the user to the existing TOTP step to complete sign-in.
              var redirectUrl = data.redirect || '{{ url_for("main.login_totp") }}';
              window.location.href = redirectUrl;
              return;
            }
            window.location.href = nextUrl;
          })
          .catch(function (err) {
            alert(String(err));
          });
      });
    })();
  </script>
{% endblock %}
